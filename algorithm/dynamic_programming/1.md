## 🍳 暴力搜索（Brute Force）
就像没有菜谱的新手厨师

**操作方式**：每次做菜都从头开始研究

**具体表现**：
- 要做鱼香肉丝？先查怎么切肉 → 再学调酱汁 → 最后学炒菜
- 下次再做鱼香肉丝，又重复整个研究过程

**特点**：
- ✅ 简单直接
- ❌ 重复劳动多（每次都要重新研究切肉）
- ❌ 效率低下（做10次菜相当于研究了10次切肉）

**对应代码**：斐波那契数列的递归写法

```cpp
int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2); // 重复计算严重
}
```

## 📝 记忆化搜索（Memoization）
像有笔记的聪明厨师

**操作方式**：
- 第一次做菜时记录每个步骤
- 后面再做时直接看笔记

**具体表现**：
- 第一次研究鱼香肉丝时，把切肉厚度、酱汁配方记下来
- 第二次直接按笔记操作，不再重复研究

**特点**：
- ✅ 避免重复劳动
- ✅ 保留自然思维流程（自上而下）
- ❌ 需要额外空间存笔记

**对应代码**：带缓存的斐波那契

```cpp
vector<int> memo(100, -1);

int fib(int n) {
    if(n <= 1) return n;
    if(memo[n] != -1) return memo[n]; // 查笔记
    return memo[n] = fib(n-1) + fib(n-2); // 记笔记
}
```

## 📊 动态规划（Dynamic Programming）
像流水线生产的专业大厨

**操作方式**：
- 提前规划所有步骤顺序
- 按固定流程批量生产

**具体表现**：
- 先集中学习切肉 → 再批量切好所有肉
- 接着统一调制酱汁 → 最后按顺序炒菜

**特点**：
- ✅ 效率最高（没有递归调用开销）
- ✅ 空间可优化（不需要保存全部历史）
- ❌ 需要提前设计生产流程

**对应代码**：自底向上的斐波那契

```cpp
int fib(int n) {
    vector<int> dp(n+1);
    dp[0] = 0; 
    dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]; // 流水线生产
    }
    return dp[n];
}
```

## 🆚 三者的核心区别

| 特性 | 暴力搜索 | 记忆化搜索 | 动态规划 |
|:----:|:--------:|:----------:|:--------:|
| **思维方向** | 自顶向下 | 自顶向下 | 自底向上 |
| **存储方式** | 不保存中间结果 | 选择性保存重要中间结果 | 系统化存储所有状态 |
| **时间复杂度** | 指数级 | 线性/多项式级 | 线性/多项式级 |
| **空间复杂度** | O(1) | O(n) | O(n) → 可优化到O(1) |

## 🌰 现实案例理解

想象计算 `fib(5)`：

| 方法 | 计算次数 | 说明 |
|------|----------|------|
| 暴力搜索 | 要计算15次 `fib(1)` | 大量重复计算 |
| 记忆化搜索 | 每个 `fib(k)` 只算1次 | 查表避免重复 |
| 动态规划 | 从 `fib(0)` 开始一步步算到 `fib(5)` | 按顺序计算 |

**就像拼乐高**：
- 🔴 暴力法：每次拆了重拼
- 🟡 记忆化：拼过的模块放旁边备用
- 🟢 DP：按说明书从底层开始搭建


##可以先定义状态，然后思考当前状态的解，如何由其子问题的解来递推。##