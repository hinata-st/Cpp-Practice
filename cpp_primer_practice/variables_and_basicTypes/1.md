
## 声明与定义
声明使得名字为程序所知，定义负责创建与名字关联的实体。   

## 引用
引用并非对象，他只是为了一个已经存在的对象所起的另一个名字。    

引用必须初始化。并且一旦定义了引用就无法在绑定到其他对象

    double dval = 3.14;
    double &refval = dval;
引用的类型要和与之绑定的对象严格匹配

不能定义引用的引用


## 指针
    int ival = 42;
    int *p = &ival;
    cout << *p;

1.指针本身也是一个对象，允许在生命周期内可以先后指向几个不同的对象。   
2.指针无需在定义的时候赋初值。
3.除了void*指针可以指向任何类型的对象。其他指针类型必须要与所指对象严格匹配。

#### 空指针    

    int *p = nullprt;
    int *p = 0;

#### void* 指针
可用于存放任意对象的地址

指针和引用的主要区别：引用是另一个对象的别名，而指针本身就是一个对象。 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。

## 复合类型的声明

    int* p;
    int *p;

这两种方式都对，*仅仅是修饰了p而已。

#### 指向指针的引用

    int i = 42;
    int *p;         //
    int *&r = p;    //r是一个对指p针的引用
    r = &i;
    *r = 0;         //将i的值改为0;
从右向左阅读有助于弄清他的真实含义。
&r说明r是一个引用。*说明r引用的是一个指针。最后声明的基本数据类型部分说明r引用的是一个int指针。

## const 限定符
`const int bufsize = 512;`  
const对象一旦创建后**其值就不能被改变**，所以const对象**必须初始化**。

默认状态下，const对象仅在文件内有效。  
如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

## const的引用

    const int ci = 1024;
    const int &r1 = ci;

**常量引用是对const的引用**
常量引用可以绑定到字面值（如42）,此时编译器会生成一个临时变量保存42，然后让r1去引用他。具体见下。

**引用的类型必须与所引用对象的类型一致**，但是有个例外，在**初始化常量引用时允许用任意表达式作为初始值**，只要改表达式的结果能转换成引用的类型即可。尤其允许一个常量引用绑定非常量的对象、字面值，甚至是一个表达式。     

    int i = 42;
    const int &r1 = i;
    const int &r2 = 42;
    const int &r3 = r1 * 2;

原因用以下例子解释

    double dval = 3.14;
    const int &r1 = dval;

此时编译器会把上诉代码变成如下：

    const int temp = dval;
    const int &r1 = dval;

r1绑定了一个临时量对象。如果r1不是常量时，就运行对r1赋值，但是此时r1绑定的是临时量，但是一般大家都不会想着把引用绑定到临时量上，所以这种行为归为违法。

#### 对const的引用可能引用一个非const的对象

    int i = 42;
    int &r1 = i;
    const int &r2 = i;

## 指针和const

    const double pi = 3.14;
    const double *cptr = &pi;

指向常量的指针不用用于改变其所指对象的值，但是没有规定那个对象的值不能通过其他途径改变。

#### const指针
常量指针必须初始化    
**不变的是指针本身而不是指向的那个值**

    int errNumb = 0;
    int *const curErr = &errNumb;
    const double pi = 3.1415;
    const double *const pip = &pi;  //pip是指向常量对象的常量指针

离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型又声明符的其余部分确定。声明符的下一个符号是*，意思是curErr是一个常量指针。同时也可以推断出pip指向的对象是一个双精度浮点性常量。

## 顶层const
顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。   
顶层const可以表示任意的对象都是常量，底层const则与指针和引用等复合类型的基本类型部分有关。   
`const int *const p3 = p2;//靠右的const是顶层const,靠左的是底层const`

## constexpr和常量表达式
常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。

#### constexpr变量
允许将变量声明为constexpr类型一遍又编译器来验证变量的值是否是一个常量表达式。
#### 字面值类型
算数类型、引用、指针都属于字面值类型。
#### 指针和constexpr
在constexpr声明中如果定义了一个指针，限定符constexpr只对指针有效，相当于顶层const

## 处理类型
#### 类型别名
`typedef double wages;`

    using SI = Sales_item;
    SI item;
#### 指针、常量和类型别名
    typedef char *pstring;
    cosnt pstring cstr = 0; != const char *cstr = 0;
前者声明了一个指向char的常量指针，后者则声明了一个指向const char 的指针
**pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。**
#### auto类型说明符

auto让编译器通过初始值来推算变量的类型。   
auto定义的变量必须有初始值。

#### 复合类型、常量和auto
编译器推断出来的auto类型有时和初始值的类型并不完全一样。
当引用被用作初始值时，编译器以引用的对象的类型作为auto的类型。   
auto一般会忽略掉顶层const

## decltype类型指示符
`decltype(f()) sum = x;`   
sum的类型就是函数f的返回类型
decltype返回改变量的类型（包括顶层const和引用在内）

#### decltype和引用
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。  
如果r是一个引用，那么decltype(r)的结果是引用类型。   
如果表达式的内容是解引用，则将得到引用类型。  

    int i = 42,*p = &i;

decltype(*p)的结果类型就是int&。  
decltype((variable))的结果永远是引用。   
decltype(variable)结果只有当variable本身是一个引用的时候才是一个引用。

## 自定义数据类型

















