<h1 style="color:blue;">by Emilia-tan</h1>

## 基本内置类型

包括算术类型和空类型，其中算术类型包含了字符、整型数、布尔值、和浮点数。

## 声明与定义（P41）
声明使得名字为程序所知，定义负责创建与名字关联的实体。   

## 引用
引用并非对象，他只是为了一个已经存在的对象所起的另一个名字。    

**引用必须初始化**。并且一旦定义了引用就无法在绑定到其他对象

    double dval = 3.14;
    double &refval = dval;
引用的类型要和与之绑定的**对象严格匹配**。

不能定义引用的引用


## 指针
    int ival = 42;
    int *p = &ival;
    cout << *p;

1. 指针本身也是一个对象，允许在生命周期内可以先后指向几个不同的对象。   
2. 指针无需在定义的时候赋初值。
3. 除了void*指针可以指向任何类型的对象。其他指针类型必须要与所指**对象严格匹配**。

#### 空指针    

    int *p = nullprt;
    int *p = 0;

#### void* 指针
可用于存放任意对象的地址

指针和引用的主要区别：引用是另一个对象的别名，而指针本身就是一个对象。 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。

## 复合类型的声明

    int* p;
    int *p;

这两种方式都对，*仅仅是修饰了p而已。

#### 指向指针的引用

    int i = 42;
    int *p;         //
    int *&r = p;    //r是一个对指p针的引用
    r = &i;
    *r = 0;         //将i的值改为0;
从右向左阅读有助于弄清他的真实含义。
&r说明r是一个引用。*说明r引用的是一个指针。最后声明的基本数据类型部分说明r引用的是一个int指针。

## const 限定符
`const int bufsize = 512;`  
const对象一旦创建后**其值就不能被改变**，所以const对象**必须初始化**。

默认状态下，const对象仅在文件内有效。  
如果想在多个文件之间共享const对象，必须在变量的**定义**之前添加extern关键字

## const的引用

    const int ci = 1024;
    const int &r1 = ci;

**常量引用是对const的引用**
常量引用可以绑定到字面值（如42）,此时编译器会生成一个临时变量保存42，然后让r1去引用他。具体见下。

**引用的类型必须与所引用对象的类型一致**，但是有个例外，在**初始化常量引用时允许用任意表达式作为初始值**，只要改表达式的结果能转换成引用的类型即可。尤其允许一个常量引用绑定非常量的对象、字面值，甚至是一个表达式。     

    int i = 42;
    const int &r1 = i;
    const int &r2 = 42;
    const int &r3 = r1 * 2;

原因用以下例子解释

    double dval = 3.14;
    const int &r1 = dval;

此时编译器会把上诉代码变成如下：

    const int temp = dval;
    const int &r1 = dval;

r1绑定了一个临时量对象。如果r1不是常量时，就运行对r1赋值，但是此时r1绑定的是临时量，但是一般大家都不会想着把引用绑定到临时量上，所以这种行为归为违法。

#### 对const的引用可能引用一个非const的对象

    int i = 42;
    int &r1 = i;
    const int &r2 = i;

## 指针和const

    const double pi = 3.14;
    const double *cptr = &pi;

指向常量的指针不用用于改变其所指对象的值，但是没有规定那个对象的值不能通过其他途径改变。

#### const指针
常量指针必须初始化    
**不变的是指针本身而不是指向的那个值**

    int errNumb = 0;
    int *const curErr = &errNumb;
    const double pi = 3.1415;
    const double *const pip = &pi;  //pip是指向常量对象的常量指针

离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型又声明符的其余部分确定。声明符的下一个符号是*，意思是curErr是一个常量指针。同时也可以推断出pip指向的对象是一个双精度浮点性常量。

## 顶层const
顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。   
顶层const可以表示任意的对象都是常量，底层const则与指针和引用等复合类型的基本类型部分有关。   
`const int *const p3 = p2;//靠右的const是顶层const,靠左的是底层const`

- 对比总结表
```cpp
写法	            const 类型	含义
const int x = 42;	顶层 const	x 本身是常量    
int *const p = &x;	顶层 const	p 是常量指针（不能改地址）   
const int *p = &x;	底层 const	p 指向的值是常量    
int const *p = &x;	底层 const	同上，等价写法   
const int &r = x;	底层 const	r 引用的对象是常量
```

👉 口诀记忆：

顶层 const：修饰变量“自己”。

底层 const：修饰变量“指向/引用的对象”。

## constexpr和常量表达式
常量表达式是指不会改变并且在编译过程就能得到计算结果的表达式。

#### constexpr变量
允许将变量声明为constexpr类型一遍又编译器来验证变量的值是否是一个常量表达式。
#### 字面值类型
算数类型、引用、指针都属于字面值类型。
#### 指针和constexpr
在constexpr声明中如果定义了一个指针，限定符constexpr只对指针有效，相当于顶层const

## 处理类型
#### 类型别名
`typedef double wages;`

    using SI = Sales_item;
    SI item;
#### 指针、常量和类型别名
    typedef char *pstring;
    cosnt pstring cstr = 0; != const char *cstr = 0;
前者声明了一个指向char的常量指针，后者则声明了一个指向const char 的指针
**pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。**
#### auto类型说明符

auto让编译器通过初始值来推算变量的类型。   
auto定义的变量必须有初始值。   
`auto a(b);`  
这行代码会根据变量 b 的类型自动推断 a 的类型，并用 b 初始化 a。

#### 复合类型、常量和auto
编译器推断出来的auto类型有时和初始值的类型并不完全一样。
当引用被用作初始值时，编译器以引用的对象的类型作为auto的类型。   
auto一般会忽略掉顶层const

## decltype类型指示符
`decltype(f()) sum = x;`   
sum的类型就是函数f的返回类型
decltype返回改变量的类型（包括顶层const和引用在内）

#### decltype和引用
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。  
如果r是一个引用，那么decltype(r)的结果是引用类型。   
如果表达式的内容是解引用，则将得到引用类型。  

    int i = 42,*p = &i;

decltype(*p)的结果类型就是int&。  
decltype((variable))的结果永远是引用。   
decltype(variable)结果只有当variable本身是一个引用的时候才是一个引用。
```cpp
特性	                auto	                          decltype    
推导来源	            初始化表达式	                   任意表达式   
是否必须初始化	        ✅ 必须有初始化	                  ❌ 不需要初始化   
顶层 const 处理	        会丢弃顶层 const	               保留原始声明类型   
引用处理	            忽略引用性（除非显式写 auto&）	    根据表达式值类别决定是否是引用    
常用场景	            定义变量时简化类型书写	            模板、泛型编程中精确获得表达式类型   
```

## 自定义数据类型

****

# 字符串、向量和数组

## 命名空间的using声明

`std::cin`的意思是要使用命名空间std中的名字cin。   

`using namespace::name;`   

一旦声明了上述语句，就可以直接访问命名空间中的名字。   

**头文件不应包含using声明**

## string类

### 定义和初始化string对象
```cpp
string s1;
string s2 = s1;s2是s1的副本
string s3 = "emilia-tan";
string s4(10,'c');          //cccccccccc
string s5("value");         //是字符值"value"的副本
```
### string对象上的操作
```cpp
os << s                 //将s写到输出流os中，返回os
is >> s                 //从is中读取字符串赋给s,字符串以空白分隔，返回is(遇到空格结束)
getline(is,s)           //遇到换行符结束
s.empty()
s.size()
s[n]
s1+s2
s1=s2
s1==s2
s1!=s2
<,<=,>,>=
```
触发getline函数返回的那个换行符实际上被丢掉了，得到的string对象中并不包含该换行符。   

size函数返回的是一个string::size_type类型的值，是一个**无符号类型**的值。   
如果一条表达式中已经有了size()函数就不在使用int了，这样可以避免混用int和unsigned带来的问题。

当把string对象和字符字面值以及字符串字面值混在一条一句中时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。   

**字符串字面值与string是不同的类型。** 

### 处理string对象中的字符

见P82

### 基于范围的for语句
```cpp
string str("emilia-tan");
//每行输出str中的一个字符
for(auto c:str)
    cout << c << endl;

string str("emilia-tan")
//转换成大写形式
for(auto &c : str)
    c = topper(r);
cout << s << endl;
```

**string对象的下标必须大于等于0而小于s.size()**

一种简单的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需要保证下标小于size()的值就可以了。

使用下标访问空字符串是非法的行为。

****
# 标准库类型vector

想使用vector,必须包含头文件`#include <vector>`

vector是模板而非类型，又vector生成的类型必须包含vector中元素的类型，例如`vector<int>`   

## 定义和初始化vector对象
```cpp
vector<T> v1                v1是一个空vector，它的潜在元素是T类型
vector<T> v2(v1)            v2中包含有v1所有元素的副本
vector<T> v2 = v1           
vector<T> v3(n,val)         v3包含了n个重复的元素，每个元素的值都是val
vector<T> v4(n)             v4包含了n个重复地执行了值初始化的对象
vector<T> v5{a,b,c....}
vector<T> v5 = {a,b,c....}
```
#### 列表初始化vector对象
`vector<string> str = {"a","the","an"};`

#### 创建指定数量的元素
`vector<int> ivec(10,-1);    //10个int类型的元素，每个都被初始化为-1`
`vector<string> svecJ(10,"hi");`

#### 值初始化
`vector<int> ivec(10);//10个元素，每个都初始化为0`    
`vector<string> svec(10);//10个元素，每个都是空string对象`

用的是圆括号，可以说提供的值是用来构造vector对象的   
用的是花括号，可以表述成我们想列表初始化该vector对象

## 向vector对象中添加元素
`v1.push_bacl(i)`

**范围for语句体内不应改变改变其所遍历序列的大小**

## 其他vector操作   
```cpp
v.empty()
v.size()            返回值的类型是由vector定义的size_type类型
v.push_back(t)
v[n]
v1 = v2
v1 = {a,b,c...}
v1 == v2
v1 != v2
<,<=,>,>=           元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小来决定
```

#### vector对象的索引

vector对象的下标也是从0开始算，下标的类型是相应的size_type类型。   

**不能用下标的形式添加元素**

**vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素**

## 迭代器介绍
 
### 使用迭代器
    //b表示v的第一个元素，e表示v尾元素的下一个位置
    auto b = v.begin(),e = v.end();//b和e的类型相同

end成员返回的迭代器被称为尾后迭代器      
如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器

```cpp
string s("emilia-tan");
auto it = s.begin(s);
it* = toupper(it*);             //将当前字符改成大写形式
```

#### 迭代器运算符
    *iter               返回迭代器iter所指元素的引用
    iter->mem           解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
    ++iter
    --iter
    iter1 == iter2

例子：把string对象的第一个字母改为大写形式
```cpp
string s("emlia-tan")
if(s.begin() != s.end())
{
    auto it = s.begin();
    *it = toupper(*it);
}
```
#### 将迭代器从一个元素移动到另一个元素

因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作

利用迭代器实现上一个例子的效果
```cpp
for(auto it = s.begin();it != s.end() && isspace(*it);++it)
{
    *it = toupper(*it);
}
```

**泛型编程**   
所有的标准库容器的迭代器都定义了==和!=，但是他们中的大多数都没有定义<运算符。   
因此我们养成使用迭代器和!=的习惯，就不用太在意用的到底是哪种类型容器

#### 迭代器类型

那些拥有迭代器的标准库类型使用**iterator**和**const_iterator**来表示迭代器的类型   
const_iterator能读取但不能修改他所指的元素类型    
iterator的对象可读可写

#### begin和end运算符

如果对象是常量,begin和end返回const_iterator    
如果对象不是常量，返回iterator

```cpp
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();   //it1的类型是vector<int>::iterator
auto it2 = cv.begin();  //it2的类型是vector<int>::const_iterator
```

`cbegin()`和`cend()`函数无论vector对象是否是常量，返回值都是const_iterator    
如果对象只需读操作而不用写操作的话可以使用这两个函数

#### 结合解引用和成员访问操作

`it->mem`和`(*it).mem`表达的意思相同

#### 某些对vector对象的操作会使迭代器失效
1. 不能在范围for循环中向vector对象添加元素
2. push_back会使该vector对象的迭代器失效

### 迭代器运算

vector和string迭代器支持的运算    

    iter + n                加上一个整数值仍是一个迭代器
    iter - n
    iter += n
    iter -= n
    iter1 - iter2           参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置
    >,>=,<,<=

使用迭代器完成了二分搜索
```cpp
//text必须是有序的
//beg和end表示我们的搜索范围
auto beg = text.begin(),end = text.end();
auto mid = text.begin() + (end - beg)/2;//初始状态下的中间点
//当还有元素尚未检查并且我们还没找到sought时执行行循环
while(mid != end && *mid != sought)
{
    if(sought < *mid)
    {
        end = mid;
    }
    else
    {
        beg = mid + 1;//能保证每次循环都缩小区间，最终查找结束。

    }
    mid = beg + (end - beg)/2;//新中点
}
```

为什么用的是 mid = beg + (end - beg) / 2, 而非 mid = (beg + end) / 2 ; ?   
解：因为两个迭代器相互之间支持的运算只有 - ，而没有 + 。 但是迭代器和迭代器差值（整数值）之间支持 +。

****
# 数组

## 定义和初始化内置数组

`int a[d];`   
a是数组的名字，d是数组的维数，维数必须大于0,编译的时候维度必须是一个常量表达式。   

```cpp
constexpr unsigned sz = 42;
int arr[10];
int *parr[sz];                  //含有42个整形指针的数组
string strs[get_size()];        //当get_size是constexpr时正确；否则错误
```

数组的元素应为对象，因此不存在引用的数组

#### 显式初始化数组元素

```cpp
const unsigned sz = 3;
int ial[sz] = {0,1,2};
int a2[] = {0,1,2};  
int a3[5] = {0,1,2};            //0,1,2,0,0
string a4[3] = {"hi","bye"};    //"hi"  "bye"  ""
```
#### 字符数组的特殊性

用字符串字面值对数组初始化，注意字符串字面值的结尾处还有一个空字符。

```cpp
char a1[] = {'c','+','+'};          //列表初始化，没有空字符
char a2[] = {'c','+','+','\0'};     //列表初始化，含有显式的空字符
char a3[] = "c++";                  //自动添加表示字符串结束的空字符
```

**不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值**

#### 理解复杂的数组声明

```cpp
int *ptrs[10];                  //ptrs是含有10个整形指针的数组
int (*parray)[10] = &arr;       //指向一个含有10个整数的数组指针
int (&arrRef)[10] = arr;        //引用一个含有10个整数的数组
```

从内向外的顺序可以帮助我们更好的理解parray的含义   
首先是圆括号括起来的部分，*parray意味着parray是一个指针，观察右边知道parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int

`int *(&arry)[10] = ptrs;//array是数组的引用，该数组含有10个指针`  

## 访问数组的元素

在使用数组下标的时候，通常将其定义为size_t类型,size_t是一种机器相关的无符号类型。   
```cpp
unsigned arr[11] = {};
for(auto i : arr)
{
    cout << i << endl;
}
```

**注意检查下标的值防止溢出**

## 指针和数组

```cpp
string nums[] = {"one","two","three"};
string *p2 = nums;//等价于*p2 = &num[0]
```
一下情况下数组的操作实际上是指针的操作   
```cpp
int ia[] = {1,2,3,2,4,5};
auto ia2(ia);
```
`auto ia2(ia);` 会将 ia 推断为 int*，因为数组名在表达式中会退化为指针。
所以 ia2 实际上是一个指向 ia 首元素的指针。相当于下面的形式    
`auto ia2(&ia[0]);`

`decltype(ia) ia3 = {1,2,3,4,5,6};`   
`decltype(ia)`返回的类型是由10个整数构成的数组

#### 指针也是迭代器

指向数组元素的指针支持vector和string的迭代器支持的运算

```cpp
int a[] = {1,2,3,4};
int *p = a;
++p;
```
```cpp
int ia[] = {0,1,2,3,4,5,6,7};
int *beg = begin(ia);
int *last = end(ia);
```
其中`last`指针指向了数组的尾元素的下一个位置，**尾后指针不能执行解引用和递增操作**。   

#### 指针运算

指向数组元素指针可以执行所有迭代器运算。
```cpp
int arr[5] = {1,2,3,4,5};
int *p = arr;
int *ip2 = ip + 4;//ip2指向arr[4]
```

两个指针相减的结果是他们之间的距离，类型是`ptrdiff_t`的标准库类型
是一种带符号类型，因为距离可能为负   

两个指针运算时，两个指针必须指向同一个对象或该对象的下一个位置

#### 解引用和指针运算的交互
```cpp
int a[5] = {1,2,3,4,5};
int *p = a;
*(p+4) = 6;//将a[5]的值改为6
```

#### 下标和指针

很多情况下使用数组的名字其实是用的一个指向数组首元素的指针，一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上诉转换操作    

```cpp
int ia[] = {0,2,4,6,8};
int *p = ia;
int i = *(p+2);//等价于i = ia[2]
int *p1 = &ia[2];
int j = p1[1];//ia[3]
int k = p[-2];//ia[0]
```
**内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样**

## C风格字符串

**c++支持c风格的字符串，但是C++程序中最好不要使用，string要比c风格字符串更安全、高效**

字符串存放在字符数组中并以空字符结束`'\0'`。

#### c标准库string函数

定义在`cstring.h`头文件中

```cpp
strlen(p)           返回p的长度，不计算空字符
strcmp(p1,p2)       p1>p2，返回一个正值
strcat(p1,p2)       将p2附加到p1之后，返回p1
strcpy(p1,p2)       将p2拷贝给p1，返回p1
```
**传入此类函数的指针必须指向以空字符作为结束的数组**

## 与旧代码的接口

#### 混用string对象和c风格字符串

出现字符串字面值的地方都可以用以空字符结束的字符数组来代替    
1. 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
2. string对象的加法运算

```cpp
string s("emilia-tan");
char *str = s;//不能用string对象初始化char*
const char * str = s.c_str();
```
c_str函数返回的是一个c风格字符串，函数返回的结果是一个指针，该指针指向一个以空字符结束的字符数组
而这个数组所处的数据与string对象一样，结果指针的类型是const char *

**执行完c_str()函数后想一直都能使用其返回的数组，最好将改数组重新拷贝一份**

#### 使用数组初始化vector对象

```cpp
int int_arr[] = {0,1,2,3,4,5};
//ivec有6个元素，分别是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr),end(int_arr));
```

用于初始化vector对象的值也可以是数组的一部分

**尽量使用vector和迭代器，避免使用内置数组和指针，应该尽量使用string，避免使用c风格的基于数组的字符串**

## 多维数组

多维数组就是数组的数组。

`int ia[3][4];//大小为3的数组，每个元素是含有4个整数的数组`

#### 多维数组的初始化

```cpp
int ia[3][4] = {        //3个元素，每个元素都是大小为4的数组
    {0,1,2,3},          //第一行的初始值
    {4,5,6,7},
    {8,9,10,11}
}
//等价与上面的方式
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
//显式地初始化每行的首元素
int ia[3][4] = {{0},{4},{8}};
//显式地初始化第1行，其他元素执行值初始化
int ix[3][4] = {0,3,6,9};
```

#### 多维数组的下标引用

如果表达式含有下标运算符的数量和数组的维度一样多，该表达式的结果将是给定类型的元素。    
反之，如果表达式含有的下标运算符数量比数组的维度下，则表达式的结果将是给定索引处的一个内层数组。  

```cpp
int arr[10][20][30] = {0};
//用arr的首元素为ia最后一行的最后一个元素赋值
ia[2][3] = arr[0][0][0];
//把row绑定到ia的第二个4元素数组上
int (&row)[4] = ia[1];
```

使用for循环来处理多维数组的元素
```cpp
constexpr size_t rowCnt = 3,colCnt = 4;
int ia[rowCnt][colCnt];
for(size_t i = 0;i != colCnt;++i)//对于每一行
{
    for(size_t j = 0;j != colCnt;++j)//对于行内每一列
    {
        ia[i][j] = i * colCnt + j;//将元素的索引作为他的值
    }
}

size_t cnt = 0;
for(auto &row : ia)//对于外层数组的每一个元素
{
    for(auto &col : row)//对于内层数组的每一个元素
    {
        col = cnt;
        ++cnt;
    }
}
```

**要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型**    
这是因为如果不是引用类型，编译器初始化时会自动将这些数组形式的元素转换成指向该数组内首元素的指针    
这样得到的类型就是int*,显然内层循环就不合法了。

#### 指针和多维数组

当使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。    
**定义指向多维数组的指针时，记得多维数组实际上是数组的数组**

```cpp
int ia[3][4];
int (*p)[4] = ia;//p指向含有4个整数的数组
p = &ia[2];

//上诉声明的圆括号必不可少，注意下列写法的区别
int *ip[4];     //含有4个整型指针的数组
int (*ip)[4];   //指向含有4个整数的数组指针
```
可以通过使用auto或者decltype就能尽可能避免在数组前面加上一个指针了
```cpp
for(auto p = ia;p != ia + 3;++p)
{
    for(auto q = *p;q != *p + 4;++q)
    {
        cout << *q << ' ';
    }   
    cout << endl; 
}

//或者使用begin()和end()
for(auto p = begin();p != end(ia);++p)
{
    for(auto q = begin(*p);q != end(*p);++q)
    {
        cout << *q << ' ';
    }
    cout << endl;
}
```

#### 类型别名简化多维数组的指针
```cpp
using int_array = int[4];//新标准下类型别名声明
typedef int int_array[4];//typedef等价声明

for(int_array *p = ia; p != ia + 3;++p)
{
    for(int *q = *p;q != *p + 4;++q)
    {
        cout << *q << ' ';
    }
    cout << endl;
}
```








































