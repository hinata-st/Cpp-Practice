<h1 style="color:blue;">by Emilia-tan</h1>

# 1、概述

除了固定大小的`array`外，其他容器都提供高效、灵活的内存管理。    
`string`和`vector`将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。

`array`不支持添加和删除元素以及改变容器大小的操作。

- 除非你有很好的理由选择其他容器，否则应使用`vector`
- 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`

# 2、容器库概览

- 容器操作    

|   |  | 
|:----|:--------:|
|类型别名|    |
| `iterator`| 此容器类型的迭代器类型|
| `const_iteraor`|可以读取元素，但不能修改元素的迭代器类型|
|`size_type`|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|`diffenrence_type`|带符号整数类型，足够保存两个迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型，与`value_type&`含义相同|
|`const_reference`|元素的const左值类型,即(`const value_type&`)|
|构造函数||
|`C c;`|默认构造函数，构造空容器|
|`C c1(c2);C c1=c2;`|构造c2的拷贝c1,c1和c2必须是相同类型|
|`C c(b,e)`|构造c,将迭代器b和e指定范围内的元素拷贝到e|
|`C c{a,b,c...};`|列表初始化c|
|`C seq(n)`|seq包含n个元素，这些元素进行了值初始化，此构造函数是explicit的|
|`C seq(n,t)`|seq包含n个初始化为值t的元素|
|赋值与swap||
| `c1 = c2`|将c1中的元素替换为c2中的元素|
|`c1 = {a,b,c...};`|将c1中的元素替换为列表中的元素|
|`a.swap(b)`|交换a和b的元素,c1和c2必须具有相同的类型|
|`swap(a,b)`|交换a和b的元素，c1和c2必须具有相同的类型|
|`seq.assign(b,e)`|将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq的元素|  
|`seq.assign(il)`|将seq中的元素替换为初始化列表il中的元素|
|`seq.assign(n,t)`|将seq中的元素替换为n个值为t的元素|
|添加/删除元素(不适用于array)|这些操作会改变容器的大小，vector和string不支持push_front和emplace_front|
|`c.push_back(t);c.emplace_back(args)`|在c的尾部创建一个值为t或由args创建的元素。返回void|
|`c.push_front(t);c.emplace_front(args)`|在c的头部创建一个值为t或由args创建的元素。返回void|
|`c.insert(p,t);c.emplace(p,args)`|在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器|
|`c.insert(p,n,t)`|在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器|
|`c.insert(p,b,e)`|将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素|
|`c.insert(p,il)`|il是一个花括号包围的元素值列表|
|`c.erase(args)`|删除args指定的元素|
|`c.clear()`|删除c中的所有元素,返回void|
|大小||
|`c,size()`|c中元素的数目|
|`c.max_size()`|c可保存的最大元素数目|
|`c.empty`|如c中存储了元素,返回false,否则返回true|
|获取迭代器||
|`c.begin(),c.end()`|返回指定C的首元素和尾元素之后位置的迭代器|
|`c.cbegin(),c.cend()`|返回const_iterator|

## 迭代器

如果一个迭代器提供某个条件，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。

- 如果`begin`与`end`相等，则范围为空
- 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素
- 我们可以对`begin`递增若干次，使得`begin==end`

## begin和end成员

`begin`和`end`操作生成指向容器中的第一个元素和尾元素之后位置的迭代器。

当不需要写访问时，应使用`cbegin`和`cend`

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配，不过，当传递迭代器参数来拷贝一个范围时，就不需要容器类型是相同的了。

接收两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。

## 关系运算符

- 如果另个容器具有相同的大小且所有元素都两两对应相等，则这两个容器相等，否则两个容器不等
- 如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中对应的元素，则较小容器小于较大容器
- 如果两个容器都不是另一个容器的前缀子序列，则他们的比较结果取决于第一个不相等的元素的比较结果







 