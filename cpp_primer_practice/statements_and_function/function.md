<h1 style="color:blue;">by Emilia-tan</h1>

# 函数

****

## 函数基础

一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。

#### 形参和实参

实参是形参的初始值，实参的类型必须与对应的形参类型匹配。函数有几个形参就必须提供相同数量的实参。

#### 函数的形参列表

函数的形参列表可以为空，但是不能省略。可以用`void`关键字来表示函数没有形参。   

#### 函数的返回类型

大多数类型能能用做函数的返回类型，一种特殊的返回类型是`void`，他表示函数不返回任何值。  
**** 

### 局部对象

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在一段时间。

形参和函数体内部定义的变量统称为局部变量。

#### 自动对象
存在于块执行期间的对象称为自动对象。当块的执行结束后，块创建的自动对象的值就变成未定义的了。   

形参是一种自动对象。  

#### 局部静态对象

局部静态对象在程序的执行路径第一次进过对象定义语句时初始化，并且直到程序终止才被销毁。    

如果局部静态变量没有显式的初始值，他将执行值初始化。内置类型的局部静态变量初始化为0。   
****

### 函数声明

函数的名字必须在使用之前声明。函数只能定义一次，但可以声明多次。   

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型。   

#### 在头文件中进行函数声明

含有函数声明的头文件应该被包含到定义函数的源文件中。


### 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

****
## 参数传递

每次调用函数时都会重新创建他的形参，并用传入的实参对形参进行初始化。

**形参初始化的机理与变量初始化一样**

形参是引用类型，他对应的实参被引用传递或者函数被传引用调用，**引用形参是他对应的实参的别名。
当实参的值被拷贝给形参时，形参和实参是两个互相独立的对象。这样的实参被值传递或者函数被传值调用。**

### 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。

**函数对形参做的所有操作都不会影响实参。**

#### 指针形参

当执行指针拷贝操作时，拷贝的是指针的值。这是两个不同的指针。因为指针使我们可以间接的访问他所指的对象，所以通过指针可以修改他所指对象的值。

**c常常使用指针类型的形参访问函数外部的对象。在c++中，建议使用引用类型的形参代替指针**

### 传引用函数

接收的参数是引用类型，和其他引用一样，引用形参绑定初始化他的对象。当引用被改变时，被改变的对象是传入函数的实参。  

#### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作。   
当某种类型不正常拷贝操作时，函数只能通过引用形参访问该类型的对象。

**如果函数无须改变引用形参的值，最好将其声明为常量引用**

#### 使用引用形参返回额外的信息

引用形参为我们一次返回多个结果提供了有效的途径。


**总结就是传值和传指针都是拷贝，引用是绑定实参；但是指针可以间接访问所指的对象，所以传指针和传引用都可以改变实参，而传值不行。**

****

### const形参和实参

`void fcn(const int i) {/*fcn能够读取i，但是不能向i写值*/}`

调用`fcn`函数时，既可以传入`const int`也可以传入`int`。

**当形参有顶层const时，传给他常量对象或者非常量对象都是可以的**

在c++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的不同。    

#### 指针或引用形参与const

可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。   

c++允许我们用字面值初始化常量引用。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改他的实参的值。   
此外，使用引用而非常量引用也会极大地限制函数所能接收的实参类型。不能把`const`对象、字面值或者需要类型转换的对象传递给普通的引用形参。

****
### 数组形参

不允许拷贝数组，使用数组时通常会将其转换成指针。    
当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。   

```cpp
//这3个函数等价
//每个函数都有一个const int *类型的形参
void print(const int *);
void print(const int[]);      //可以看出来，函数的意图是作用与一个数组
void print(const int[10]);    //这里的维度元素表示我们期望数组含有多少元素，实际不一定
```

如果我们传给`print`函数的是一个数组，则实参自动的转换成指向数组首元素的指针数组的大小对函数的调用没有影响。

**和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界**

#### 使用标记指定数组的长度

要求数组本身包含一个结束标记，比如c风格字符串，最后一个字符为空字符。
```cpp
void print(const char *cp)
{
    if(cp)              //若cp不是一个空指针
        while(*cp);     //只要指针所指的字符不是空字符
}
```

#### 使用标准库规范

```cpp
void print(const int *beg,const int *end)
{
    while(beg != end)
        cout << *beg++ << endl;
}
int j[2] = {0,1};
print(begin(j),end(j));
```

#### 显式传递一个表示数组大小的形参

```cpp
void print(const int ia[],size_t size)
{
    for(size_t i = 0;i != size;i++)
    {
        cout<< ia[i] << endl;
    }
}
int j[2] = {0,1};
print(j,end(j) - begin(j));
```

#### 数组形参和const

只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

```cpp
void print(int (&arr)[10])
{
    for(auto elem : arr)
    {
        cout << elem << endl;
    }
}
```

**`&arr`两端的括号必不可少**

这一用法限制了print函数的可用性，只能将函数作用与大小为10的数组。

#### 传递多维数组

所谓的多维数组就是数组的数组。   
`void print(int (*matrix)[10],int rowsize) {/*  */};`    
`void print(int matrix[][10],int rowsize) {/*  */};//两个定义等价`    
matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组指针。  

****
### main:处理命令行选项

`int main(int argc,char *argv[]) {....}`

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

### 含有可变形参的函数

如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型；如果实参的类型不同，可以编写可变参数模板。

#### `initializer_list` 形参

`initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组。
```cpp
initializer_list提供的操作
initializer_list<T> lst;                默认初始化；T类型元素的空列表
initializer_list<T> lst{a,b,c....};     列表中的元素是const
lst2(lst)                               原始列表和副本共享元素
lst2 = lst                              
lst.size()
lst.begin()
lst.end()

void error_msg(initializer_list<string> il)
{
    for(auto beg = il.begin();beg != il.end();++beg)
    {
        cout << *beg << "  ";
    }
    cout << endl;
}
//expected,actual是string对象
error_msg({"emilia-tan",expected,actual})
```

在范围for循环中使用initializer_list对象时，应该将循环控制变量声明成引用类型，initializer_list对象中的元素都是常量，我们无法修改initializer_list对象中的元素的值。

****

## 返回类型和retuen语句

```cpp
return;
return expression;
```

### 无返回值的函数

没有返回值的return语句只能用在返回类型是`void`的函数中。这类函数最后会隐式地执行`return`。

一个返回类型是`void`的函数也能使用`return`语句的第二种表达形式，此时`return`语句的`expression`必须是另一个返回`void`的函数。

### 有返回值的函数

`return`语句的第二种形式提供了函数的结果。如果函数的返回类型不是`void`,则函数内每条`return`语句必须返回一个值。`return`语句返回值的类型必须与函数的返回类型相同，或者能隐式的转换过去。

**在含有return语句的循环后面应该也有一条return语句**

#### 值是如何被返回的

返回一个值的方式和初始化一个变量或形参的方式完全一样。   

如果函数返回引用，则该引用仅是所引对象的一个别名。   

#### 不要返回局部对象的引用和指针

函数终止意味着局部变量的引用将指向不在有效的内存区域。    

#### 返回类类型的函数和调用运算符

调用运算符符合左结合律。

`auto sz = shorterString(s1,s2).size();//得到短string对象的长度`

#### 引用返回左值

调用一个返回引用的函数得到左值，其他返回类型得到右值。

```cpp
char &get_val(string &str,string::size_type ix)
{
    return str[ix];
}
get_val(s,0) = 'A';
```
#### 列表初始化返回值

函数可以返回花括号包围的值的列表。

```cpp
vector<string> process()
{
    if(..)
    {
        return {};//返回一个空的vector对象
    }
    else
    {
        return {"emilia","tan"};//返回列表初始化的vector对象
    }
}
```

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。  

#### 主函数mian的返回值

允许`main`函数没有`return`语句直接结束，没有`return`语句编译器将隐式插入一条返回`0`的`return`语句。

#### 递归

在递归函数中，一定有某条路径是不包含递归调用的。

****

### 返回数组指针

数组不能被拷贝，所以函数不能返回数组。但是函数可以返回数组的指针或引用。

```cpp
using arrT = int[10];
arrT* func(int i);          //func返回一个指向含有10个整数的数组的指针
```

#### 声明一个返回数组指针的函数

必须牢记被定义的名字后面数组的维度
```cpp
int arr[10];            //arr是一个含有10个整数的数组
int *p1[10];            //p1是一个含有10个指针的数组
int (*p2)[10] = &arr;   //p2是一个指针，它指向含有10个整数的数组
```

返回指针数组的函数形式如下   
`Type (*function(parameter_list))[dimension]`     
Type表示元素的类型，dimension表示数组的大小。    
`int (*func(int i))[10];`

- `(*func(int i))`意味着我们可以对函数调用的结果执行解引用操作
- `(*func(int i))[10]`表示解引用func的调用将得到一个大小是10的数组
- `int (*func(int i))[10]`表示数组中的元素是int类型

#### 使用尾置返回类型

`//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组`    
`auto func(int i) -> int(*)[10];`

****
## 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，称之为重载函数。

#### 定义重载函数

```cpp
Record lookup(const Account&)
Record lookup(const Phone&)
Record lookup(const Name&)
```

编译器根据实参的类型2确定应该调用哪个函数

不允许两个函数除了返回类型外其他所有的要素全部相同。

#### 判断两个形参的类型是否相同

使用类型别名的两个形参类型相同

#### 重载和const形参

一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开。

如果类型是指针或者引用的话可以区分

#### const_cast和重载

。。。

#### 调用重载的函数

当两个重载函数参数数量相同且参数类型可以互相转换时，编译器处理就比较麻烦。   


### 重载与作用域

如果在内层作用域中声明名字，他将隐藏外层作用域中声明的同名实体。   

**c++语言中，名字查找发生在类型检查之前**

****
## 特殊用途语言特性

默认实参、内敛函数和constexpr函数

### 默认实参

`typedef string::size_type sz;`  
`string screen(sz ht = 24,sz wid = 80,char background = ' ');`

一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。   

#### 使用默认实参调用函数

默认实参负责填补函数调用缺少的尾部实参。   
例如想要覆盖`background`的默认值，必须为`ht`和`wid`提供实参。

#### 默认实参声明

在给定的作用域中一个形参只能被赋予一次默认实参

**通常，应该在函数声明中指定默认实参并将该声明放在合适的头文件中。**

#### 默认实参初始值

局部变量不能作为默认实参。   

用作默认实参名字在函数声明所在的作用域内解析，而这些名字的求值过程中发生在函数调用时。

****

### 内联函数和constexpr

调用函数一般比求等价表达式的值要慢一些

#### 内敛函数可避免函数调用的开销

将函数指定为内敛函数，通常就是将他在每个调用电商“内敛地”展开。

在函数的返回类型前面上加上关键字`inline`，这样就可以将它声明为内敛函数。

```cpp
inline const string & shorterString(const string &s1,const string &s2)
{
    return s1.size() <= s2.size()? s1 : s2;
}
```

**内敛说明只是向编译器发出一个请求，编译器可以选择忽略这个请求**


内敛机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内敛递归函数。    

#### constexpr函数

constexpr函数是指能用于常量表达式的函数。遵循几项规定：**函数的返回类型以及所有形参的类型都得是字面值类型，而已函数体中必须有且只有一条return语句**。    

```cpp
constexpr int new_sz() { return 42;}
constexpr int foo = new_sz();
```
执行该初始任务时，编译器把对constexpr函数的调用替换成其结果值。constexpr函数被隐式地指定为内敛函数。

允许constexpr函数的返回值并非一个常量。

**constexpr函数不一定返回常量表达式**

#### 把内敛函数和constexpr函数放在头文件内

内敛函数和constexpr函数通常定义在头文件内。

****

### 调试帮助

用到两项预处理功能： `assert`和`NDEBUG`

#### assert预处理宏

assert是一种预处理宏。所谓预处理宏其实就是一个预处理变量，行为有点类似与内敛函数。使用一个表达式作为他的条件。

`assert(expr);`

如果表达式为假，`assert`输出信息并终止程序的执行。为真，什么也不做。

assert宏常用于检查“不能发生”的条件。

#### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。
如果定义了NDEBUG,则assert什么也不做。默认状态下没有定义NDEBUG。    

可以使用一个`#define`语句定义NDEBUG,从而关闭调试状态。   
同时编译器都提供了一个命令行选项使我们可以定义预处理变量。

也可以使用NDEBUG编写自己的条件调试代码

```cpp
void print(const int ia[],size_t size)
{
    #ifndef NDEBUG
        // _ _func_ _时编译器定义的一个局部静态变量，用于存放函数的名字
        cerr << _ _func_ _ << ":array size is " << size << endl;
    #endif
}
```

```cpp
_ _func_ _      存放函数的名字
_ _FILE_ _      存放文件名的字符串字面值
_ _LINE_ _      存放当前行号的整型字面值
_ _TIME_ _      存放文件编译时间的字符串字面值
_ _DATE_ _      存放文件编译日期的字符串字面值
```

****

## 函数匹配


  





