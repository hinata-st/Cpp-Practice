<h1 style="color:blue;">by Emilia-tan</h1>

# 函数

****

## 函数基础

一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。

#### 形参和实参

实参是形参的初始值，实参的类型必须与对应的形参类型匹配。函数有几个形参就必须提供相同数量的实参。

#### 函数的形参列表

函数的形参列表可以为空，但是不能省略。可以用`void`关键字来表示函数没有形参。   

#### 函数的返回类型

大多数类型能能用做函数的返回类型，一种特殊的返回类型是`void`，他表示函数不返回任何值。  
**** 

### 局部对象

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在一段时间。

形参和函数体内部定义的变量统称为局部变量。

#### 自动对象
存在于块执行期间的对象称为自动对象。当块的执行结束后，块创建的自动对象的值就变成未定义的了。   

形参是一种自动对象。  

#### 局部静态对象

局部静态对象在程序的执行路径第一次进过对象定义语句时初始化，并且直到程序终止才被销毁。    

如果局部静态变量没有显式的初始值，他将执行值初始化。内置类型的局部静态变量初始化为0。   
****

### 函数声明

函数的名字必须在使用之前声明。函数只能定义一次，但可以声明多次。   

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型。   

#### 在头文件中进行函数声明

含有函数声明的头文件应该被包含到定义函数的源文件中。


### 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

****
## 参数传递

每次调用函数时都会重新创建他的形参，并用传入的实参对形参进行初始化。

**形参初始化的机理与变量初始化一样**

形参是引用类型，他对应的实参被引用传递或者函数被传引用调用，引用形参是他对应的实参的别名。  
当实参的值被拷贝给形参时，形参和实参是两个互相独立的对象。这样的实参被值传递或者函数被传值调用。

### 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。

**函数对形参做的所有操作都不会影响实参。**

#### 指针形参

当执行指针拷贝操作时，拷贝的是指针的值。这是两个不同的指针。因为指针使我们可以间接的访问他所指的对象，所以通过指针可以修改他所指对象的值。

**c常常使用指针类型的形参访问函数外部的对象。在c++中，建议使用引用类型的形参代替指针**

### 传引用函数

接收的参数是引用类型，和其他引用一样，引用形参绑定初始化他的对象。当引用被改变时，被改变的对象是传入函数的实参。  

#### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作。   
当某种类型不正常拷贝操作时，函数只能通过引用形参访问该类型的对象。

**如果函数无须改变引用形参的值，最好将其声明为常量引用**

#### 使用引用形参返回额外的信息

引用形参为我们一次返回多个结果提供了有效的途径。


**总结就是传值和传指针都是拷贝，引用是绑定实参；但是指针可以间接访问所指的对象，所以传指针和传引用都可以改变实参，而传值不行。**

****

### const形参和实参

`void fcn(const int i) {/*fcn能够读取i，但是不能向i写值*/}`

调用`fcn`函数时，既可以传入`const int`也可以传入`int`。

当形参有顶层const时，传给他常量对象或者非常量对象都是可以的

在c++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的不同。    

#### 指针或引用形参与const

可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。   

c++允许我们用字面值初始化常量引用。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改他的实参的值。   
此外，使用引用而非常量引用也会极大地限制函数所能接收的实参类型。不能把`const`对象、字面值或者需要类型转换的对象传递给普通的引用形参。

****
### 数组形参

不允许拷贝数组，使用数组时通常会将其转换成指针。    
当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。   

```cpp
//这3个函数等价
//每个函数都有一个const int *类型的形参
void print(const int *);
void print(const int[]);      //可以看出来，函数的意图是作用与一个数组
void print(const int[10]);    //这里的维度元素表示我们期望数组含有多少元素，实际不一定
```

如果我们传给`print`函数的是一个数组，则实参自动的转换成指向数组首元素的指针数组的大小对函数的调用没有影响。

**和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界**

#### 使用标记指定数组的长度

要求数组本身包含一个结束标记，比如c风格字符串，最后一个字符为空字符。
```cpp
void print(const char *cp)
{
    if(cp)              //若cp不是一个空指针
        while(*cp);     //只要指针所指的字符不是空字符
}
```

#### 使用标准库规范

```cpp
void print(const int *beg,const int *end)
{
    while(beg != end)
        cout << *beg++ << endl;
}
int j[2] = {0,1};
print(begin(j),end(j));
```

#### 显式传递一个表示数组大小的形参

```cpp
void print(const int ia[],size_t size)
{
    for(size_t i = 0;i != size;i++)
    {
        cout<< ia[i] << endl;
    }
}
int j[2] = {0,1};
print(j,end(j) - begin(j));
```

#### 数组形参和const

只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

```cpp
void print(int (&arr)[10])
{
    for(auto elem : arr)
    {
        cout << elem << endl;
    }
}
```

**`&arr`两端的括号必不可少**

这一用法限制了print函数的可用性，只能将函数作用与大小为10的数组。

#### 传递多维数组

所谓的多维数组就是数组的数组。   
`void print(int (*matrix)[10],int rowsize) {/*  */};`    
`void print(int matrix[][10],int rowsize) {/*  */};//两个定义等价`    
matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组指针。  

****
### main:处理命令行选项