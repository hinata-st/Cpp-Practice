<h1 style="color:blue;">by Emilia-tan</h1>

# 表达式 178

## 基础

c++定义了一元运算符、二元运算符、三元运算符    
一些符号可以作为一元运算符也可以作为二元运算符
#### 运算对象转换

在表达式求值的过程中，运算对象常常由一种类型转换成另一种类型。比如小整数类型`(bool,char,short)`通常会被提升成较大的整数类型`(int)`   
#### 重载运算符

IO库的`>>`和`<<`运算符以及`string`对象、`vector`对象和迭代器使用的运算符都是**重载的运算符**

使用重载运算符时，运算对象的类型和返回值类型，都是由该运算符定义的，但是运算的个数、运算符的优先级和结合律都是无法改变的   

#### 左值和右值

当一个对象被作用右值的时候，用的是对象的值（内容）；当对象被作用左值的时候，用的是对象的身份（在内存中的位置）

不同的运算符对运算对象的要求各不相同   
有几种熟悉的运算符是要用到左值的：   
1. 赋值运算符需要一个（非常量）左值作为其左侧运算对象，等到的结果是一个左值
2. 取地址符作用于一个左值运算对象，返回一**个指向该运算对象的指针，指针是一个右值**
3. 内置解引用运算符、下标运算符、迭代器解引用运算符有、string和vector的下标运算符的求值结果都是左值
4. 内置类型和迭代器的递增递减运算符作用于左值对象，所得的结果也是左值

eg:如果表达式的求值结果是一个左值，`decltype`作用于该表达式得到的是一个引用类型,假定`p`的类型是`int*`，因为**解引用运算符生成左值**,所以`decltype(*p)`的结果是`int&`

## 优先级和结合律

如果优先级相同，则其组合规则由结合律决定。算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从**左到右**的顺序组合运算对象。

## 求值顺序

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为

`cout << i << " " << ++i << endl;//未定义的`

`&&,||,?:,(,)`这4种运算符规定了运算对象的求值顺序，比如`&&`先求左侧对象的值，只有当左侧运算对象的值为真才继续求右值运算对象的值

**拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑要求**

## 算术运算符

运算符`%`参与取余运算的运算对象必须是整数   
除法运算中，规定商一律向0取整（即直接切除小数部分）    
如果`m%n`不等与0，则它的符合和`m`相同

```cpp
eg:
-21 % -8 = -5
21 % -5 = 1
21 % 6 = 3
21 / 6 = 3
21 / 7 = 3
```
## 逻辑和关系运算符

逻辑和关系运算符的返回值都是`bool`类型,运算对象和求值结果都是右值   

逻辑与和逻辑或运算符当且仅当左侧运算符对象无法确定表达式的结果才会计算右侧运算对象的值，称为“短路求值”

进行比较运算时，出费比较的对象是布尔类型，否则不要使布尔字面值true和false作为运算对象

## 赋值运算符
赋值运算符的左侧对象必须是一个可修改的左值

赋值运算的结果是它的左侧的对象。如果赋值运算符的左右两个对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。

允许使用花括号括起来的初始值列表作为赋值语句的右侧

如果左侧运算对象是内置类型`（int,double,char）`，那么初始值列表最多包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间。   
```cpp
double d = 3.14;
int i{d};     // ❌ 非法：double 转 int 可能丢小数部分
```

#### 赋值运算符满足右结合律

`ival = jval = 0;//正确，都被赋0`
相当于`jval = 0,ival = jval;`

**因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号**

## 递增和递减运算符

递增和递减运算符有两种形式：前置版本和后置版本。     

这两种运算符必须作用与左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象的原始值的副本作为右值返回。  

**除非必须，否则不用递增递减运算符的后置版本**

#### 在一条语句中混用解引用和递增运算符

后置运算符的有限级高于解引用运算符    
`*pbeg++`等价于`*(pbeg++)`   
这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。   

#### 运算对象可按任意顺序求值
`*beg = toupper(*beg++);//错误：赋值语句未定义`   
赋值运算符左右两端的运算对象都用到了beg，并且右侧的运算符对象还改变了beg的值，所以该赋值语句是未定义的。

## 成员访问运算符

点运算符和箭头运算符都可用于访问成员
表达式`ptr->mem`等价于`(*ptr).mem`

解引用运算符的优先级低于点运算符

箭头运算符作用与一个指针类型的运算对象，结果是一个左值。点运算符分两种情况：   
如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。

## 条件运算符

`cond?expr1:expr2;`

条件运算符可以嵌套    
条件运算符满足右结合律

#### 在输出表达式中使用条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。
`cout << ((grade < 60)? "fail" : "pass");`

## 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。

一般来说，如果运算对象是“小整形”，则它的值会被自动提升成较大的整数类型。

**关于符号位如何处理没用明确规定，所以强烈建议将位运算符用于处理无符号类型**

#### 使用位运算符

#### 移位运算符（又叫IO运算符）满足左结合律

`cout << "hi" << "there" << endl` 等同于`((cout << "hi") << "there") << endl;`

## sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，   
其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：
1. `sizeof (type)   类型大小，必须加括号`
2. `sizeof expr    表达式结果类型的大小，括号可省略`   
第二种形式中，sizeof返回的是表达式结果类型的大小。  
两者计算结果在编译器确定，不会真的执行表达式

`sizeof`满足右结合律

`sizeof`运算符的结果部分依赖于其作用的类型
1. 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果为1
2. 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小
3. 对指针执行`sizeof`运算得到指针本身所在空间的大小
4. 对解引用指针执行`sizeof`运算得到指针所指向的对象所占空间的大小，指针不需要有效
5. 对数组执行`sizeof`运算得到整个数组所占空间的大小，`sizeof`不会把数组转换成指针来处理
6. 对`string`和`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占了多少空间。

计算数组的元素个数
`constexpr size_t sz = sizeof(ia)/sizeof(*ia);`

## 逗号运算符
按照从左到右一次求值

逗号运算符真正的值是右侧表达式的值

## 类型转换

隐式转换：自动根据类型转换规则设法将运算对象的类型统一后再求值

何时发生隐式转换
1. 比`int`类型小的整型值首先提升为较大的整数类型
2. 在条件中，非布尔值转换成布尔类型
3. 初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型
4. 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一个类型
5. 函数调用时也会发生类型转换

### 算术转换
 
把一种算术类型转换成另一种算术类型   
其中运算符的运算对象将转换成最宽的类型   
当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型

#### 整形提升
负责把小整数类型转换成较大的整数类型

#### 无符号类型的运算对象

原则：先进行整型提示，然后小向大的变（P142）

### 其他隐式类型转换（P144）

数组转换成指针：大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针
指针的转换：   
转换成布尔类型   
转换成常量   
类类型定义的转换   

### 显式转换

**有时不得不使用强制类型转换，但是这种方法本质上是非常危险的**

#### 命名的强制类型转换

`cast-name<type>(expression)`  
type是转换目标类型，expression是要转换的值，如果type是引用类型，则结果是左值。   
cast-name是`static_cast、dynamic_cast、const_cast、reinterpret_cast`中的一种

#### `static_cast`
不包含底层const    
需要把一个较大的算术类型赋值给较小的类型时，非常有用

#### `const_cast`
去掉const性质

#### `reinterpret_cast`

本质依赖机器

**避免强制类型转换**

#### 旧式的强制类型转换

```cpp
type (expr);
(type) expr;
```












